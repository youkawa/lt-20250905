# 実装計画: Notebook Report Weaver

## フェーズ 1: プロジェクト基盤と環境構築 (Foundation & DevOps)

このフェーズでは、開発を開始するための基盤を構築します。3つのサービスすべてのリポジトリ、開発環境、CI/CDパイプラインの初期設定を行い、開発者が一貫した環境で効率的に作業できるようにします。

-   [ ] **全般 (General)**
    -   [ ] Monorepo（例: Turborepo）または個別のGitリポジトリ構造を決定し、セットアップする
    -   [ ] プロジェクト全体のコーディング規約（ESLint, Prettier, Black, Ruff）を定義し、設定ファイルを作成する
    -   [ ] `docker-compose.yml`を作成し、フロントエンド、メインAPI、Notebook処理サービス、PostgreSQLデータベースのコンテナを定義する
    -   [ ] 開発者が`docker-compose up`コマンド一つで全サービスをローカル起動できる環境を整備する
-   [ ] **フロントエンド (Next.js)**
    -   [ ] `create-next-app`を使用してNext.js 14プロジェクトを初期化する
    -   [ ] TypeScript, Tailwind CSS, Shadcn/ui CLIをセットアップする
    -   [ ] 必要なnpmパッケージをインストールする (`zustand`, `dnd-kit`, `@datalayer/jupyter-ui`, `axios`)
    -   [ ] 設計文書に基づいたディレクトリ構造 (`app`, `components`, `lib`, `store`) を作成する
-   [ ] **メインAPI (NestJS)**
    -   [ ] NestJS CLIを使用して新しいプロジェクトを初期化する
    -   [ ] Prismaを導入し、PostgreSQLデータベースへの接続設定を行う
    -   [ ] 必要なnpmパッケージをインストールする (`@nestjs/config`, `@prisma/client`, `passport`, `jsonwebtoken`)
    -   [ ] Dockerfileを作成し、開発および本番用のコンテナイメージをビルドできるようにする
-   [ ] **Notebook処理サービス (FastAPI)**
    -   [ ] Poetryまたはpipenvを使用してPythonプロジェクトを初期化する
    -   [ ] FastAPI, Uvicornをセットアップし、基本的なヘルスチェックエンドポイント (`/health`) を作成する
    -   [ ] 必要なPythonパッケージをインストールする (`nbformat`, `python-pptx`, `kaleido`, `fastapi`, `uvicorn`)
    -   [ ] Dockerfileを作成し、コンテナイメージをビルドできるようにする
-   [ ] **CI/CD (GitHub Actions)**
    -   [ ] 各サービスに対して、Push時にLintとテストを実行する基本的なCIワークフローを作成する
    -   [ ] Dockerイメージをビルドし、コンテナリポジトリ（例: AWS ECR, Docker Hub）にプッシュするワークフローの雛形を作成する

## フェーズ 2: コアバックエンド開発 (Main API - NestJS)

アプリケーションの核となるデータモデルとビジネスロジックを実装します。認証基盤を確立し、フロントエンドが必要とする基本的なCRUD APIを整備します。

-   [ ] **データベースとモデル (Prisma)**
    -   [ ] `schema.prisma`ファイルに`User`, `Project`, `Report`, `Template`のモデルを定義する
    -   [ ] `Report`モデルの`content`フィールドを`Json`型として定義し、`ReportContentItem`を格納できるようにする
    -   [ ] Prisma Migrateを実行して、開発用データベースにテーブルを作成する
    -   [ ] Prisma Clientを生成し、NestJSサービスから利用できるようにする
-   [ ] **認証 (NextAuth.js連携)**
    -   [ ] ユーザー認証用の`AuthModule`を作成する
    -   [ ] Email/PasswordまたはOAuthプロバイダ（例: Google, GitHub）を用いた認証戦略を実装する
    -   [ ] JWT（JSON Web Token）の発行と検証ロジックを実装する
    -   [ ] 認証済みユーザーのみがアクセスできる保護ルート（Authenticated Guard）を実装する
-   [ ] **APIエンドポイント (CRUD)**
    -   [ ] **Projects API**:
        -   [ ] `ProjectsModule`, `ProjectsController`, `ProjectsService`を作成する
        -   [ ] `POST /projects` - 新規プロジェクト作成
        -   [ ] `GET /projects` - 認証ユーザーのプロジェクト一覧取得
        -   [ ] `GET /projects/:id` - 特定プロジェクトの詳細取得
        -   [ ] `DELETE /projects/:id` - プロジェクト削除
    -   [ ] **Reports API**:
        -   [ ] `ReportsModule`, `ReportsController`, `ReportsService`を作成する
        -   [ ] `POST /reports` - プロジェクト内に新規レポートを作成
        -   [ ] `GET /reports/:id` - 特定レポートのデータ取得
        -   [ ] `PUT /reports/:id` - レポート内容（`content`や`metadata`）の更新（自動保存用）
-   [ ] **単体テスト (Vitest/Jest)**
    -   [ ] 各サービスクラスの主要なビジネスロジック（例: プロジェクト作成時の所有者設定）に対する単体テストを作成する

## フェーズ 3: Notebook処理マイクロサービス開発 (Python/FastAPI)

専門的なNotebook解析とPPTX生成処理を担当するマイクロサービスを構築します。このサービスはステートレスであり、メインAPIから呼び出されることを想定しています。

-   [ ] **Notebook解析エンドポイント**
    -   [ ] `POST /parse-notebook` エンドポイントを実装する
    -   [ ] アップロードされた`.ipynb`ファイル（`UploadFile`）を受け取る
    -   [ ] `nbformat`ライブラリを使用してファイルを読み込み、セル単位のJSON配列に変換する
    -   [ ] 解析エラー（不正なJSON形式など）に対する例外処理と適切なエラーレスポンスを実装する
    -   [ ] 解析結果のJSONをレスポンスとして返す
-   [ ] **PPTX生成エンドポイント（同期版）**
    -   [ ] `POST /generate-pptx` エンドポイントを実装する
    -   [ ] レポートのJSONデータ（`Report`インターフェースに準拠）とテンプレートファイルパスをリクエストボディで受け取る
    -   [ ] `python-pptx`を使用して指定されたテンプレート`.pptx`ファイルを読み込む
    -   [ ] レポートの`content`配列をループ処理し、各要素をスライドに変換するロジックを実装する
        -   [ ] `TextBoxItem`: テキストボックスとしてスライドに追加する
        -   [ ] `NotebookCellItem` (コード/Markdown): テキストとしてスライドに追加する
        -   [ ] `NotebookCellItem` (グラフ出力): `Kaleido`を使用してグラフを静的画像（PNG）に変換し、スライドに挿入する
    -   [ ] 生成されたPPTXファイルをバイナリレスポンスとして返す
-   [ ] **エラーハンドリングとロギング**
    -   [ ] テンプレートファイルが見つからない場合のエラー処理を実装する
    -   [ ] `Kaleido`による画像変換失敗時のエラー処理を実装する
    -   [ ] 処理の主要なステップで構造化ロギングを追加する

## フェーズ 4: フロントエンドの骨格とコアUI実装 (Frontend Scaffolding)

ユーザーが操作するインターフェースの基盤を構築します。Next.jsのルーティング、レイアウト、状態管理ストア、そして再利用可能なUIコンポーネントを準備します。

-   [ ] **ルーティングとレイアウト (Next.js App Router)**
    -   [ ] `app/layout.tsx`で全体共通のレイアウト（ヘッダー、フッターなど）を定義する
    -   [ ] ダッシュボードページ (`/dashboard`)、レポート編集ページ (`/projects/[projectId]`) のルートを作成する
    -   [ ] 認証が必要なページを保護するためのルートグループまたはミドルウェアを設定する
-   [ ] **状態管理 (Zustand)**
    -   [ ] `store/useReportStore.ts`を作成し、`Report`インターフェースに基づいた状態（`metadata`, `content`）とアクション（`addContentItem`, `updateContentItem`, `reorderContentItems`）を定義する
    -   [ ] `store/useUIStore.ts`を作成し、UIの状態（`isExportModalOpen`, `activePanel`）とアクションを定義する
-   [ ] **APIクライアント**
    -   [ ] `lib/apiClient.ts`に`axios`インスタンスを作成し、ベースURLや認証ヘッダーの自動付与などの共通設定を行う
    -   [ ] API通信エラーを捕捉し、統一された形式で処理する共通エラーハンドリング機構を実装する
-   [ ] **UIコンポーネントの雛形作成 (Shadcn/ui)**
    -   [ ] `Button`, `Input`, `Dialog`, `Card`など、アプリケーション全体で利用する基本的なUIコンポーネントを`components/ui`にセットアップする
    -   [ ] `ReportEditor`の主要な構成要素である`NotebookSelectorPanel`, `ReportCanvas`, `PreviewPanel`のコンポーネントファイルを作成し、静的なレイアウトを配置する

## フェーズ 5: 主要機能実装: レポート作成と編集

アプリケーションの中核機能であるレポートエディタを実装します。ユーザーがNotebookをインポートし、ドラッグ＆ドロップでレポートを構築できるようにします。

-   [ ] **プロジェクト管理**
    -   [ ] ダッシュボードページでプロジェクト一覧をAPIから取得し表示する
    -   [ ] 新規プロジェクト作成モーダルとAPI連携を実装する
-   [ ] **Notebookインポートと表示 (`NotebookSelectorPanel`)**
    -   [ ] ファイルアップロードUIを実装し、選択された`.ipynb`ファイルをメインAPIに送信する機能を実装する
    -   [ ] メインAPIはリクエストをFastAPIの`/parse-notebook`に中継し、結果をフロントエンドに返す
    -   [ ] 解析されたセルデータを`@datalayer/jupyter-ui`の`Notebook`または`Cell`コンポーネントを使用してパネル内に一覧表示する
    -   [ ] リスト仮想化（`react-window`等）を導入し、大規模Notebookの表示パフォーマンスを確保する
    -   [ ] セルを選択した際に、`useReportStore`のアクションを呼び出して`ReportCanvas`に追加する機能を実装する
-   [ ] **レポート編集 (`ReportCanvas`)**
    -   [ ] `useReportStore`から`content`配列を取得し、各要素（`NotebookCellItem`, `TextBoxItem`）をリスト表示する
    -   [ ] `dnd-kit`を導入し、リストアイテムのドラッグ＆ドロップによる並べ替え機能を実装する
    -   [ ] 並べ替え完了時に`useReportStore`の`reorderContentItems`アクションを呼び出す
    -   [ ] テキストボックス追加ボタンを実装し、クリック時に新規`TextBoxItem`をストアに追加する
    -   [ ] テキストボックスの内容を編集できるリッチテキストエディタ（例: Tiptap）を組み込む
-   [ ] **リアルタイムプレビュー (`PreviewPanel`)**
    -   [ ] `useReportStore`の状態を購読し、`content`配列の変更に応じてプレビューを再レンダリングする
    -   [ ] プレビューの更新処理に`debounce`を適用し、頻繁な更新によるパフォーマンス低下を防ぐ
-   [ ] **自動保存**
    -   [ ] `useReportStore`の状態が変更されたことを検知し、一定時間後（例: 2秒後）に`PUT /reports/:id` APIを呼び出して変更をサーバーに保存する`useEffect`フックを実装する

## フェーズ 6: 主要機能実装: レポートのエクスポートと非同期処理

レポートを最終的な成果物（PPTX）として出力する機能を実装します。時間のかかる処理であるため、ユーザー体験を損なわない非同期処理の仕組みを構築します。

-   [ ] **フロントエンド (`ExportModal`)**
    -   [ ] エクスポートボタンと、クリック時に表示される`ExportModal`コンポーネントを実装する
    -   [ ] モーダル内にメタデータ（タイトル、作成者など）を入力するフォームを作成する
    -   [ ] 「エクスポート実行」ボタンクリック時に、現在のレポートデータとメタデータをメインAPIのエクスポート開始エンドポイントに送信する
    -   [ ] APIから即時返却されるジョブIDを保持し、UIを「処理中」の状態に更新する
-   [ ] **バックエンド (非同期ジョブキュー)**
    -   [ ] NestJSにジョブキューライブラリ（例: BullMQ）を導入し、設定を行う
    -   [ ] `POST /reports/:id/export` エンドポイントを実装する。このエンドポイントはリクエストを受け取るとジョブキューにPPTX生成ジョブを追加し、ジョブIDを即座に返す
    -   [ ] ジョブを処理するワーカーを実装する。ワーカーはFastAPIの`/generate-pptx`エンドポイントを呼び出し、生成されたPPTXファイルを受け取る
    -   [ ] ワーカーは受け取ったファイルをS3などのストレージに保存し、ジョブの状態（完了/失敗）とダウンロードURLをデータベースに記録する
-   [ ] **処理状況の通知とダウンロード**
    -   [ ] フロントエンドからジョブの状況を問い合わせるためのエンドポイント (`GET /export-jobs/:jobId`) をメインAPIに実装する
    -   [ ] フロントエンドは、ジョブIDを使って定期的にポーリングを行い、ジョブの完了を検知する
    -   [ ] ジョブが完了したら、UIを更新し、データベースに保存されたURLへのダウンロードリンクをユーザーに提示する

## フェーズ 7: 管理者機能: テンプレート管理

管理者ユーザー向けの機能として、レポートの基盤となるPPTXテンプレートを管理する画面を実装します。

-   [ ] **バックエンド (Main API)**
    -   [ ] テンプレートファイルのアップロードを受け付けるエンドポイント (`POST /templates`) を実装する（ファイルはS3等に保存）
    -   [ ] テンプレートの一覧取得、情報更新、削除を行うCRUD APIを実装する
    -   [ ] APIに管理者権限をチェックするGuardを適用する
-   [ ] **フロントエンド (`TemplateManager`)**
    -   [ ] 管理者専用のUIページ (`/admin/templates`) を作成する
    -   [ ] テンプレートアップロードフォームを実装する
    -   [ ] 現在登録されているテンプレートの一覧をAPIから取得し、テーブル表示する
    -   [ ] デフォルトテンプレートの設定や、テンプレートの削除機能を実装する

## フェーズ 8: 統合テストと品質保証 (Testing & QA)

アプリケーション全体の品質を保証するため、各レイヤーでのテストを実装し、主要なユーザーフローが期待通りに動作することを確認します。

-   [ ] **単体テスト (Vitest)**
    -   [ ] フロントエンドのZustandストアのアクションとリデューサーのロジックをテストする
    -   [ ] フロントエンドのユーティリティ関数（データ形式変換など）をテストする
    -   [ ] バックエンドの各サービスクラスの複雑なビジネスロジックをテストする
-   [ ] **コンポーネントテスト (React Testing Library)**
    -   [ ] `ReportCanvas`コンポーネントで、アイテムの追加や削除が正しくレンダリングに反映されることをテストする
    -   [ ] ドラッグ＆ドロップ操作をシミュレートし、状態が正しく更新されることをテストする
    -   [ ] `ExportModal`で、フォーム入力と送信が正しく機能することをテストする
-   [ ] **E2Eテスト (Playwright)**
    -   [ ] ログインからプロジェクト作成までの一連のフローをテストする
    -   [ ] レポート作成の主要フロー（Notebookアップロード → セル選択 → 並べ替え → エクスポート開始）を自動化テストでカバーする
    -   [ ] テストが失敗した場合にCIで通知されるように設定する

## フェーズ 9: 最終調整とデプロイ準備 (Polish & Deployment)

アプリケーションを本番環境にデプロイするための最終準備を行います。パフォーマンスの最適化、環境変数の設定、デプロイメントパイプラインの構築を含みます。

-   [ ] **パフォーマンス最適化**
    -   [ ] `react-dev-tools`や`Lighthouse`を使用してフロントエンドのパフォーマンスボトルネックを特定し、改善する
    -   [ ] バックエンドAPIのレスポンスタイムを監視し、必要に応じてデータベースクエリのインデックス最適化を行う
    -   [ ] FastAPIサービスの負荷に応じてコンテナ数を自動調整するオートスケーリング設定（AWS Fargate/ECS）を構成する
-   [ ] **環境設定**
    -   [ ] 本番環境、ステージング環境、開発環境用の環境変数ファイル（`.env`）を準備する
    -   [ ] データベース接続情報やAPIキーなどの機密情報を安全に管理する仕組み（例: AWS Secrets Manager）を導入する
-   [ ] **デプロイメント (CI/CD)**
    -   [ ] GitHub Actionsのワークフローを完成させ、mainブランチへのマージをトリガーとして各サービスが自動でデプロイされるように設定する
        -   [ ] フロントエンド: Vercelへの自動デプロイ
        -   [ ] バックエンド (NestJS & FastAPI): Dockerイメージをビルドし、AWS ECS/Fargateにデプロイ
    -   [ ] デプロイ前のヘルスチェックと、デプロイ後のスモークテストをパイプラインに組み込む
-   [ ] **ドキュメンテーション**
    -   [ ] 各サービスリポジトリの`README.md`を更新し、ローカルでのセットアップ方法やデプロイ手順を明記する
    -   [ ] 主要なAPIエンドポイントの仕様をドキュメント化する（例: Swagger/OpenAPI）
